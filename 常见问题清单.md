

### 1、openFeign直连api，不经过nacos

```java
@FeignClient(value = "acc", url = "http://localhost:8092/acc")
public interface FeignAccountService {
    @PostMapping("/user/list")
    Result userList(@RequestBody UserListDTO userListDTO);
}
```

参考：[[FEIGN 直连API，FEIGN不使用EUREKA直接调用微服务](https://www.greenhtml.com/archives/feign-direct-api.html)](https://www.greenhtml.com/archives/feign-direct-api.html)

### 2、openFeign日志打印

feign提供了日志打印功能，可以通过配置来调整日志级别，从而了解Feign中HTTP请求的细节
日志级别有一下四个：
none：默认的，不显示任何日志
basic：仅记录请求方法，URL响应状态码，及执行时间
headers：除了basic中定义的信息之外还有请求和响应头信息
full：除了headers中定义的信息之外，还有请求和响应的正文及元数据
具体配置如下：
一、 新建配置类FeignConfig

```java
@Configuration
public class FeignConfig {
    @Bean
    Logger.Level feignLoggerLevel(){
        return Logger.Level.FULL;
    }
}
1234567
```

二、yml文件

```java
logging:
  level:
     #feogn日志以什么级别监视那个接口
     com.zhutianlu.springcloud.service.PaymentFeignService: debug
```

### 3 Feign Hystrix (HystrixCommonKey) 设置单独接口的超时时间和FallBack

如何配置好`Hystrix`和`Ribbon`的超时时间呢？
其实是有套路的。因为`Feign`的请求：其实是`Hystrix`+`Ribbon`。`Hystrix`在最外层，然后再到`Ribbon`，最后里面的是`http`请求。所以说。`Hystrix`的熔断时间必须大于`Ribbon`的 ( `ConnectTimeout` + `ReadTimeout` )。而如果`Ribbon`开启了重试机制，还需要乘以对应的重试次数，保证在`Ribbon`里的请求还没结束时，`Hystrix`的熔断时间不会超时。

**先说结论：HystrixCommonKey生成方法：类名#方法名(入参类型)**

```yaml
hystrix:
  threadpool:
    default:
      # 核心线程池大小  默认10
      coreSize: 20
      # 最大最大线程池大小
      maximumSize: 30
      # 此属性允许maximumSize的配置生效。 那么该值可以等于或高于coreSize。 设置coreSize <maximumSize会创建一个线程池，该线程池可以支持maximumSize并发，但在相对不活动期间将向系统返回线程。 （以keepAliveTimeInMinutes为准）
      allowMaximumSizeToDivergeFromCoreSize: true
      # 请求等待队列
      maxQueueSize: 10
      # 队列大小拒绝阀值 在还未超过请求等待队列时也会拒绝的大小
      queueSizeRejectionThreshold: 10
  command:
    LimitCheckApi#rcsLimitCheck(RpcRequest):  #default全局有效 默认值为 commonKey commonKey生成方法在 Feign.configKey(target.type(), method) 中
      fallback:
        enabled: true
      execution:
        timeout:
          #如果enabled设置为false，则请求超时交给ribbon控制,为true,则超时作为熔断根据
          enabled: true
        isolation:
          #隔离策略，有THREAD和SEMAPHORE
          #THREAD - 它在单独的线程上执行，并发请求受线程池中的线程数量的限制
          #SEMAPHORE - 它在调用线程上执行，并发请求受到信号量计数的限制
          #对比：https://www.cnblogs.com/java-synchronized/p/7927726.html
          thread:
            timeoutInMilliseconds: 800 #断路器超时时间，默认1000ms
    LimitCheckApi#testTimeOutFallBack(long):
      fallback:
        enabled: true
      execution:
        timeout:
            #如果enabled设置为false，则请求超时交给ribbon控制,为true,则超时作为熔断根据
            enabled: true
        isolation:
          #隔离策略，有THREAD和SEMAPHORE
          #THREAD - 它在单独的线程上执行，并发请求受线程池中的线程数量的限制
          #SEMAPHORE - 它在调用线程上执行，并发请求受到信号量计数的限制
          #对比：https://www.cnblogs.com/java-synchronized/p/7927726.html
          thread:
            timeoutInMilliseconds: 800 #断路器超时时间，默认1000ms
 
feign:
  hystrix:
    enabled: true
```

参考: 

[Hystrix针对某个方法单独设置超时时间](https://blog.csdn.net/jerry010101/article/details/90143919?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-2&spm=1001.2101.3001.4242)

[SpringCloud OpenFeign超时配置详解](https://blog.csdn.net/a1036645146/article/details/108297183)